title=Padronizando Nomes de Objeto - Banco de Dados
date=2009-05-08
type=post
tags=nomear-objeto,padrao,banco-de-dados
status=published
~~~~~~

<p><br />Primeiro definimos a extensão dos arquivos que conterão as sentenças de criação dos objetos do banco de dados:<br /></p><br /><table border="0"><br /><tbody><br /><tr><br /><td>&lt;modulo&gt;.tbs</td><br /><td>Tablespace (Tablespace)- Script de criação do(s) espaço(s) de armazenamento</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.vw</td><br /><td>View (visão)-Script de criação da visões</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.usr</td><br /><td>Schema (esquema)- Criação do Proprietário do Módulo (Schema), juntamente com a role(papel) de aplicação e usário(s) correspondente(s)</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.grt</td><br /><td>Grant (Permissão)- Script que estabelece as permissões a outros usuário e a role de aplicação</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.rvk</td><br /><td>Revoke (Permissão)- Script que revoga as permissões a outros usuário e a role de aplicação</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.syn</td><br /><td>Synonym (Sinônimo)- Script que estabelece os sinônimos dos objetos a outros usuários</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.tab</td><br /><td>Table (Tabela)- Script de criação das tabelas</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.con</td><br /><td>Constraint (Restrição)- Script de criação das restrições de integridade</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.ind</td><br /><td>Index (Índice)- Script de criação dos índeces</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.trg</td><br /><td>Trigger (Gatilho)- Script de criação dos gatilhos</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.seq</td><br /><td>Sequence (Sequência)- Script de criação das sequências</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.prc</td><br /><td>Stored Procedure (Procedimento Armazenado)- Script de criação de procedimentos armazenados</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.fnc</td><br /><td>Stored Function (Função Armazenada)- Script de criação de funções armazenadas</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.pks</td><br /><td>Package Specification (Especificação de Pacote) - Script de criação das especificações dos pacotes</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.pkb</td><br /><td>Package Body (Corpo de Pacote) - Script de criação do corpo dos pacotes</td><br /></tr><br /><tr><br /><td>&lt;modulo&gt;.sql</td><br /><td>Reponsável por chamar/executar os outros arquivos em uma sequencia apropriada:</td><br /></tr><br /></tbody></table><br /><table><br /><tr><br /><th>Para Tabelas</th><br /><th>Descrição</th><br /><th>Exemplo</th><br /></tr><br /><tr><br /><td>&lt;prefixo&gt;_&lt;nometabela&gt;</td><td>onde &lt;prefixo&gt; deverá ser letras representando o módulo em que esta tabela pertença.</td><td>ger_pessoa</td><br /></tr><br /></table> <br /><table><br /><tr><br /><th>Para Visão</th><br /><th>Descrição</th><br /><th>Exemplo</th><br /></tr><br /><tr><br /><td>&lt;prefixo&gt;_&lt;nomevisao&gt;_vw</td><td>onde &lt;prefixo&gt; deverá ser letras representando o módulo em que esta tabela pertença.</td><td>ger_funcionario_vw</td><br /></tr><br /></tr><br /></table> <br /><table><br /><tr><br /><th>Para Sequências</th><br /><th>Descrição</th><br /><th>Exemplo</th><br /></tr><br /><tr><br /><td>&lt;prefixo&gt;_&lt;nometabela&gt;_sequence</td><td>onde &lt;prefixo&gt; deverá ser letras representando o módulo em que esta tabela pertença.</td><td>ger_funcionario_sequence</td><br /></tr><br /></table> <br /><table><br /><tr><br /><th>Para Colunas</th><br /><th>Descrição</th><br /><th>Exemplo</th><br /></tr><br /><tr><br /><td>&lt;cd&gt;_&lt;nometabela&gt;</td><td>para coluna representando a chave primaria da tabela.</td><td>cd_pessoa</td><br /></tr><br /><tr><br /><td>&lt;cd&gt;_&lt;nometabelaestrangeira&gt;</td><td>para coluna(s) representando a presença de chave estrangeira.</td><td>cd_municipio</td><br /></tr><br /><tr><br /><td>&lt;cd&gt;_&lt;nometabelaestrangeira&gt;&lt;significadodorelacionamento&gt;</td><td>para coluna(s) representando a presença de chave estrangeira.</td><td>cd_municipionaturalidade</td><br /></tr><br /><tr><br /><td>&lt;fl&gt;_&lt;nomecampo&gt;</td><td>para coluna representando campo lógico(verdadeiro ou falso).</td><td>fl_dependente, fl_encerrado</td><br /></tr><br /><br /><tr><br /><td>&lt;dt&gt;_&lt;nomecampo&gt;</td><td>para coluna representando campo data.</td><td>dt_nascimento</td><br /></tr><br /><tr><br /><td>&lt;hr&gt;_&lt;nomecampo&gt;</td><td>para coluna representando campo tempo.</td><td>hr_saida</td><br /></tr><br /><tr><br /><td>&lt;nu&gt;_&lt;nomecampo&gt;</td><td>para coluna representando campo numerico.</td><td>nu_leicriacao</td><br /></tr><br /></table><br /><p><br />Para nomear constraints, devemos usar um padrão porque não pode haver repetição de nomes dos mesmos (limitado a 30 caracteres - limitação do oracle).<br /></p><br /><table><br /><tr><br /><th>Para Constraints</th><br /><th>Descrição</th><br /><th>Exemplo</th><br /></tr><br /><tr><br /><td>&lt;nome da tabela com prefixo&gt;_&lt;pk&gt;</td><td>para chave primaria.</td><td>constraint sys_usuario_pk primary key (cd_usuario) enable</td><br /></tr><br /><tr><br /><td>&lt;nome da tabela com prefixo&gt;_&lt;uk&gt;</td><td>para indice unico.</td><td>constraint sys_usuario_uk unique (login, email) enable</td><br /></tr><br /><tr><br /><td>&lt;nome da tabela origem sem prefixo&gt;_&lt;to&gt;_&lt;nome da tabela atual(destino sem prefixo&gt;_&lt;fk&gt;</td><td>para coluna(s) representando a presença de chave estrangeira.</td><td>constraint entidade_to_subentidade_fk foreign key (id_entidade) references kira.sys_entidade (id_entidade) enable</td><br /></tr><br /><tr><br /><td>&lt;nome da tabela sem prefixo&gt;_&lt;nome da coluna&gt;_&lt;ck&gt;_&lt;um digito - caso ocorra repeticao&gt;</td><td>para check.</td><td>create table ergon.ergon_regras_compara_ff<br />(<br />regra number(6,0) constraint regras_compara_ff_regra_ck_0 not null enable,<br />fl_ativa_1 char(1 byte) default 'n' constraint rg_cp_ff_fl_ativa_1_ck_0 not null enable,<br />fl_ativa_2 char(1 byte) default 'n' constraint rg_cp_ff_fl_ativa_2_ck_0 not null enable,<br />fl_ativa_3 char(1 byte) default 'n' constraint rg_cp_ff_fl_ativa_3_ck_0 not null enable,<br />limite_diferenca number(11,2),<br />constraint ergon_regras_compara_ff_pk primary key (regra) enable,<br />constraint rg_cp_ff_fl_ativa_1_ck_1 check (fl_ativa_1 in ('s', 'n')) enable novalidate,<br />constraint rg_cp_ff_fl_ativa_2_ck_2 check (fl_ativa_2 in ('s', 'n')) enable novalidate,<br />constraint rg_cp_ff_fl_ativa_3_ck_3 check (fl_ativa_3 in ('s', 'n')) enable novalidate<br />) ;</td><br /></tr><br /></table> <br /><p><br /><strong>Nota:</strong> em todos os casos acima, sendo o nome do objeto grande, devemos abreviar o nome do mesmo.<br />ex.:<br />aplicacoes = apli (4)<br />aplicacao_funcoes = apfu (2:2)<br />aplicacao_funcao_papeis = apfp (2:1:1)<br />aplicacao_funcao_papel_bananas = afpb (1:1:1:1)<br />aplicacao_funcao_papel_banana_macas = (Seja criativo!)<br /></p><br /><br /><strong>REFERENCIA:</strong> <a href="http://www.oracle-base.com/articles/misc/NamingConventions.php">NamingConventions.php</a><br /><p><br />Uso essa estratégia há algum tempo e fica muito fácil de trabalhar e manter. <br /></p><br /><p><br />Você adota uma notação?<br />Qual notação você usa?<br /></p><br />